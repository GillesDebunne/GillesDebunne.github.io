---
layout: post
title: Devoxx 2014 - Day 3
---
## Keynotes

An inspiring first opening keynote from a musician who's also a programer. Pushing us to be more creative in our work, pursuing our own personal goal.

## Conferences

## Apps for kids

A list of good practices when designing apps for little kids. Mostly common sense, but worth getting the slides to use as a checklist.

### Parsers

Although we believe we have learned them at school, parsers are not that simple. A dynamic presentation proved it, going from LL1 to PEG and finally to GLL (Generalized LL) to handle the ambiguities of C++.

### Quickies

#### Git deliver
A plugin to use git as a delivery tool, like on heroku. Git with hook scripts, mostly for source and dynamic language deployment.

#### Maths for recommandations

Weighted averages, similarities between users and between products, leading to recommandations. The maths are pretty simple indeed, but more heuristics are needed for a real applications based on domain specificities.

### Flexible scope

Probably the presentation I've preferred in the conference. Check it out on Parley's when it's available.

Agile needs to spread to business, so that the whole industry process can be tuned, and not just the software process. This reactive capacity is needed since Time / Humans / Locale are unpredictable dimensions and must be coped by flexibility.

We are mostly using *negative metrics* in our industry, such as # of bugs, duplicated code or even velocity. But they are only alerts that something is wrong, not a proof that we are right, and only trying to optimize these is bad. He makes an analogy with blood pressure for humans.

We need higher picture victory conditions, such as a *change condition* in a user story to show its value and decide on its success. 
An example of flexibility is being able to remove user stories, features and abandon code based on feedback.

> User stories are survivable experiments.

One needs a global picture to drive flexibility. Analogy with a GPS, targeting a goal, but able to able to adapt live to the situation.

Nice stories, references and talk. I've noted ["Adapt"](http://www.amazon.com/gp/product/1250007550) from Tim Hartford.

### 33 Tricks

After a long introduction, he presented a bunch of inspiring and useful libraries and tricks (Lumbock, Guava, LambdaJ,...), to freshen our coding habits.

### Go for Java√Østes

Really cool presentation, tailored for Java programers and presenting the Go language. Detailing the strong choices that were made and showing some sample code detailing the core system of concurrency based on message passing that act as locks and make concurrent code seemingly easy.

### Extremist programming

How 'weird' people actually change the world. New disruptive ideas emerge out of some chaos and we should try them out instead of repeating the same practices over and over. Like trying out a new crazy languages, adding constraints or looking at other fields. Follow their @weirddev for such a daily kata.

### Les Cast coders

Amazing how these guys on stage have exactly the same voice as those on one of my podcasts.

## Conclusion

Technology is at the core of the digital revolution, but the programer (us), does not seems to be at its center. 

He is a mere executant, not well understood by the other actors, who don't understand this programming activity either. 

There is a communication issue here, between the idea and the code, which prevents new projects to bloom. Humans are part of that chain, and although there are less and less different roles involved, the programer is an essential link here. His success and the success of his projects will depend on his ability to communicate with the other actors.

## Personal

I'm not fitted for this kind of conferences. The pace and format of sessions makes me want to watch them on Parleys, or better, get the slides with speaker notes.

Still, strangely, watching other developers talk about their work has the effect of pushing me to my keyboard, to do my own programs, try some of the presented techniques, prove that I'm too a programer.
